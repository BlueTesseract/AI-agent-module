def alphabeta(player, state, max_depth):
    return minimax_alpha(player, state, max_depth, 0, alpha=-inf, beta=inf)

def minimax_alpha(player, state, max_depth, alpha, beta):
    if game_end(state):
        if is_winner(player, state):
            return win_value
        elif is_winner(opponent(player), state):
            return lost_value
        else
            return draw_value

    if current_depth > max_depth:
        return state_heuristic_function(player, state)

    for s' in all_allowed_next_states(state):
        alpha = max(alpha, minimax_beta(player, s', max_depth, current_depth+1, alpha, beta))
        if alpha >= beta:
            return beta
    return alpha

def minimax_beta(player, state, max_depth, alpha, beta):
    if game_end(state):
        if is_winner(player, state):
            return win_value
        elif is_winner(opponent(player), state):
            return lost_value
        else
            return draw_value

    if current_depth > max_depth:
        return state_heuristic_function(player, state)

    for s' in all_allowed_next_states(state):
        beta = min(beta, minimax_alpha(player, s', max_depth, current_depth+1, alpha, beta))
        if alpha >= beta:
            return alpha
    return beta
